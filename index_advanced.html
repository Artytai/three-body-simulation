
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Three-Body Problem — Advanced (Symplectic + Adaptive RKF45)</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f1a2b; --ink:#eef3ff; --muted:#9fb1d4; --grid:#ffffff14;
    --p1:#ff5f6d; --p2:#39d98a; --p3:#62d0ff; --merge:#ffd166; --accent:#86b7ff; --ok:#39d98a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1000px 700px at 70% 20%,#0d1732 0%,var(--bg) 55%);color:var(--ink);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #layout{display:grid;grid-template-columns:360px 1fr;grid-template-rows:auto 1fr auto;grid-template-areas:"panel header" "panel main" "panel footer";gap:10px;height:100%;padding:10px}
  #panel{grid-area:panel;background:linear-gradient(180deg,var(--panel),#0a1526);border:1px solid #ffffff18;border-radius:12px;padding:12px;overflow:auto}
  #header{grid-area:header;display:flex;align-items:baseline;gap:12px}
  #main{grid-area:main;position:relative;border-radius:12px;overflow:hidden;border:1px solid #ffffff18;box-shadow:0 20px 60px #0008}
  #footer{grid-area:footer;font-size:12px;opacity:.85}
  canvas{width:100%;height:100%;display:block}
  h2{margin:.25rem 0 .5rem 0;font-size:1rem}
  .section{margin-bottom:12px;padding-bottom:10px;border-bottom:1px dashed #ffffff1f}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
  .row3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:8px}
  .row4{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:8px}
  label{font-size:12px;display:flex;flex-direction:column;gap:4px}
  input,select,button,textarea{background:#0b1527;color:var(--ink);border:1px solid #ffffff22;border-radius:8px;padding:8px}
  textarea{width:100%;min-height:88px}
  button{cursor:pointer;transition:transform .06s ease,background .25s ease}
  button:hover{transform:translateY(-1px)}
  .btn{background:#0b1527}
  .btn-primary{background:linear-gradient(180deg,#123a64,#0b2a49);border-color:#15507f}
  .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid #ffffff22;border-radius:999px;padding:6px 10px;background:#ffffff0a;font-size:12px}
  .dot{width:10px;height:10px;border-radius:50%}
  .muted{color:var(--muted)}
  .kbd{border:1px solid #ffffff22;border-radius:6px;padding:1px 6px;background:#0d1c36;font-size:11px}
  details{border:1px solid #ffffff22;border-radius:10px;padding:8px;background:#0a1526}
  details>summary{cursor:pointer;user-select:none}
  .hud{position:absolute;left:8px;top:8px;display:flex;gap:8px;flex-wrap:wrap}
  #mini{position:absolute;right:12px;bottom:12px;width:280px;height:180px;border:1px solid #ffffff22;border-radius:10px;background:#0a1425;overflow:hidden}
  #mini canvas{width:100%;height:100%}
</style>
</head>
<body>
  <div id="layout">
    <aside id="panel">
      <div class="section">
        <h2>Three‑Body Problem — Advanced</h2>
        <div class="muted">Symplectic Leapfrog & Yoshida‑4, classic RK4, and **adaptive RKF45 (Cash–Karp)** with error control, live conservation (E, |P|, |L|), collisions/merging, COM frame, presets, and import/export state.
        </div>
      </div>
      <div class="section">
        <div class="row"><button id="play" class="btn-primary">▶ Play</button><button id="step" class="btn">Step</button></div>
        <div class="row"><button id="reset" class="btn">Reset</button><button id="clear" class="btn">Clear Trails</button></div>
        <div class="row"><button id="fig8" class="btn">Preset: Figure‑8</button><button id="lagrange" class="btn">Preset: Lagrange</button></div>
      </div>
      <div class="section">
        <div class="row">
          <label>Integrator
            <select id="integrator">
              <option value="verlet" selected>Verlet (symplectic)</option>
              <option value="yoshida4">Yoshida 4 (symplectic)</option>
              <option value="rk4">RK4</option>
              <option value="rkf45">RKF45 (adaptive)</option>
            </select>
          </label>
          <label>Base dt
            <input id="dt" type="number" step="0.0001" value="0.01" />
          </label>
        </div>
        <div class="row">
          <label>G
            <input id="G" type="number" step="0.0001" value="1" />
          </label>
          <label>Softening ε
            <input id="eps" type="number" step="0.0001" value="0.02" />
          </label>
        </div>
        <div class="row">
          <label>Speed (steps/frame)
            <input id="speed" type="number" step="1" value="1" />
          </label>
          <label>Trail length
            <input id="trailLen" type="number" step="10" value="1500" />
          </label>
        </div>
        <div class="row">
          <label><input id="showGrid" type="checkbox" checked /> Show grid</label>
          <label><input id="showVec" type="checkbox" /> Show velocity vectors</label>
        </div>
      </div>
      <div class="section">
        <h2>Adaptive RKF45</h2>
        <div class="row">
          <label>Abs tol
            <input id="tolAbs" type="number" step="1e-8" value="1e-6" />
          </label>
          <label>Rel tol
            <input id="tolRel" type="number" step="1e-8" value="1e-5" />
          </label>
        </div>
        <div class="row">
          <label>dt min
            <input id="dtMin" type="number" step="1e-6" value="1e-4" />
          </label>
          <label>dt max
            <input id="dtMax" type="number" step="1e-3" value="0.05" />
          </label>
        </div>
        <div class="row">
          <label>Safety factor
            <input id="safety" type="number" step="0.01" value="0.9" />
          </label>
          <label>Max scale per step
            <input id="scaleMax" type="number" step="0.1" value="2.0" />
          </label>
        </div>
        <div class="row">
          <label><input id="rkfClamp" type="checkbox" checked/> Clamp dt to [min,max]</label>
          <label><input id="rkfRejectPause" type="checkbox"/> Pause on repeated rejects</label>
        </div>
      </div>
      <div class="section">
        <h2>Bodies</h2>
        <div class="row3">
          <label>m₁<input id="m1" type="number" step="0.01" value="1"/></label>
          <label>m₂<input id="m2" type="number" step="0.01" value="1"/></label>
          <label>m₃<input id="m3" type="number" step="0.01" value="1"/></label>
        </div>
        <div class="row3">
          <label>x₁<input id="x1" type="number" step="0.01" value="-0.97000436"/></label>
          <label>x₂<input id="x2" type="number" step="0.01" value="0.97000436"/></label>
          <label>x₃<input id="x3" type="number" step="0.01" value="0"/></label>
        </div>
        <div class="row3">
          <label>y₁<input id="y1" type="number" step="0.01" value="0.24308753"/></label>
          <label>y₂<input id="y2" type="number" step="0.01" value="-0.24308753"/></label>
          <label>y₃<input id="y3" type="number" step="0.01" value="0"/></label>
        </div>
        <div class="row3">
          <label>v₁x<input id="vx1" type="number" step="0.01" value="0.466203685"/></label>
          <label>v₂x<input id="vx2" type="number" step="0.01" value="0.466203685"/></label>
          <label>v₃x<input id="vx3" type="number" step="0.01" value="-0.93240737"/></label>
        </div>
        <div class="row3">
          <label>v₁y<input id="vy1" type="number" step="0.01" value="0.43236573"/></label>
          <label>v₂y<input id="vy2" type="number" step="0.01" value="0.43236573"/></label>
          <label>v₃y<input id="vy3" type="number" step="0.01" value="-0.86473146"/></label>
        </div>
        <div class="row">
          <button id="apply" class="btn-primary">Apply Above</button>
          <button id="com" class="btn">Zero Total Momentum</button>
        </div>
        <div class="row">
          <label><input id="merge" type="checkbox"/> Merge on collision</label>
          <label>Collision R<input id="collideR" type="number" step="0.001" value="0.02"/></label>
        </div>
        <div class="row">
          <label><input id="elastic" type="checkbox"/> Use elastic collisions (if not merging)</label>
          <label class="muted">Tip: leave both off to let bodies pass through.</label>
        </div>
      </div>
      <div class="section">
        <h2>Import / Export</h2>
        <div class="row"><button id="export" class="btn">Export JSON</button><button id="import" class="btn">Import JSON</button></div>
        <textarea id="io" placeholder='Paste JSON here or copy out'></textarea>
      </div>
      <div class="section">
        <details>
          <summary>Help & Shortcuts</summary>
          <ul>
            <li><span class="kbd">Space</span> Play/Pause · <span class="kbd">S</span> Step · <span class="kbd">R</span> Reset · <span class="kbd">C</span> Clear trails</li>
            <li>Drag to pan · Scroll to zoom · Double‑click canvas to recenter</li>
            <li>Use <b>Verlet/Yoshida‑4</b> for better long‑term energy behavior; use <b>RKF45</b> to adapt dt across close approaches.</li>
          </ul>
        </details>
      </div>
    </aside>

    <header id="header">
      <h1 style="margin:0;font-size:18px">Three‑Body Problem · Advanced Integrators</h1>
    </header>

    <main id="main">
      <div class="hud">
        <span class="pill">E <span id="E">—</span></span>
        <span class="pill">|P| <span id="P">—</span></span>
        <span class="pill">|L| <span id="L">—</span></span>
        <span class="pill">dt <span id="dtView">—</span></span>
      </div>
      <canvas id="view"></canvas>
      <div id="mini"><canvas id="miniCanvas"></canvas></div>
    </main>

    <footer id="footer" class="muted">Energy, linear momentum, and angular momentum should remain nearly constant with symplectic methods for small dt; RKF45 adapts dt to maintain local error bounds through close encounters.</footer>
  </div>

<script>
'use strict';
// ========================= Utilities =========================
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('miniCanvas');
const miniCtx = miniCanvas.getContext('2d');
let W=0,H=0,DPR=Math.max(1,window.devicePixelRatio||1);
function resize(){
  const r = canvas.parentElement.getBoundingClientRect();
  W = Math.floor(r.width); H = Math.floor(r.height);
  canvas.width = Math.floor(W*DPR); canvas.height = Math.floor(H*DPR);
  miniCanvas.width = Math.floor(miniCanvas.clientWidth*DPR || 280*DPR);
  miniCanvas.height = Math.floor(miniCanvas.clientHeight*DPR || 180*DPR);
  canvas.style.width=W+'px'; canvas.style.height=H+'px';
  const m = document.getElementById('mini');
  const mr = m.getBoundingClientRect();
  miniCanvas.style.width = mr.width+'px'; miniCanvas.style.height = mr.height+'px';
}
window.addEventListener('resize', resize); resize();

// world <-> screen
let zoom = 250; let offset = {x:0,y:0};
function w2s(v){ return {x: (W/2)+(v.x-offset.x)*zoom, y: (H/2)-(v.y-offset.y)*zoom}; }
function s2w(p){ return {x: offset.x + (p.x-W/2)/zoom, y: offset.y - (p.y-H/2)/zoom}; }

// vector helpers
function add(a,b){return {x:a.x+b.x,y:a.y+b.y}}; function sub(a,b){return {x:a.x-b.x,y:a.y-b.y}};
function mul(a,s){return {x:a.x*s,y:a.y*s}}; function norm(a){return Math.hypot(a.x,a.y)};
function dot(a,b){return a.x*b.x+a.y*b.y}; function crossz(r,v){return r.x*v.y - r.y*v.x};

// ========================= State =========================
let G = 1.0, eps = 0.02; let trailLen = 1500; let showGrid = true, showVec=false;
let collideR = 0.02; let mergeOn = false; let elasticOn=false;
let baseDt = 0.01; let speed = 1; let running = false; let integrator='verlet';
// RKF45 params
let tolAbs=1e-6, tolRel=1e-5, dtMin=1e-4, dtMax=0.05, safety=0.9, scaleMax=2.0, rkfClamp=true, rkfRejectPause=false;
let dtAdaptive = baseDt; let rkfRejectStreak=0;

let bodies = [];
function defaultBodies(){
  bodies = [
    {m:1, r:{x:-0.97000436, y: 0.24308753}, v:{x: 0.4662036850, y: 0.4323657300}, color:'#ff5f6d', trail:[]},
    {m:1, r:{x: 0.97000436, y:-0.24308753}, v:{x: 0.4662036850, y: 0.4323657300}, color:'#39d98a', trail:[]},
    {m:1, r:{x: 0.0,        y: 0.0       }, v:{x:-0.9324073700, y:-0.8647314600}, color:'#62d0ff', trail:[]},
  ];
}

defaultBodies(); zeroCOM();

function zeroCOM(){
  const P = bodies.reduce((p,b)=>add(p,mul(b.v,b.m)),{x:0,y:0});
  const M = bodies.reduce((s,b)=>s+b.m,0);
  const vcm = mul(P,1/M);
  bodies.forEach(b=> b.v = sub(b.v, vcm));
}

function deepCopy(){ return bodies.map(b=>({m:b.m, r:{x:b.r.x,y:b.r.y}, v:{x:b.v.x,y:b.v.y}})); }

// accelerations with softening
function accelOn(i, state){
  const a={x:0,y:0}; const bi = state[i];
  for(let j=0;j<state.length;j++){ if(i===j) continue; const bj=state[j];
    const dx=bj.r.x-bi.r.x, dy=bj.r.y-bi.r.y; const d2 = dx*dx+dy*dy+eps*eps; const inv=1/Math.sqrt(d2); const inv3=inv*inv*inv;
    const s = G * bj.m * inv3; a.x += dx*s; a.y += dy*s;
  }
  return a;
}

// energy, momentum, angular momentum
function energy(){
  let K=0; bodies.forEach(b=> K += 0.5*b.m*(b.v.x*b.v.x + b.v.y*b.v.y));
  let U=0; for(let i=0;i<bodies.length;i++) for(let j=i+1;j<bodies.length;j++){
    const bi=bodies[i], bj=bodies[j]; const dx=bi.r.x-bj.r.x, dy=bi.r.y-bj.r.y; U += - G*bi.m*bj.m / Math.sqrt(dx*dx+dy*dy+eps*eps);
  }
  return K+U;
}
function momentum(){ const P=bodies.reduce((p,b)=>add(p,mul(b.v,b.m)),{x:0,y:0}); return P; }
function angMomentum(){ let Lz=0; bodies.forEach(b=>{ Lz += b.m * crossz(b.r, b.v); }); return Lz; }

function updateHUD(){
  document.getElementById('E').textContent = energy().toFixed(6);
  const P = momentum(); document.getElementById('P').textContent = Math.hypot(P.x,P.y).toExponential(3);
  document.getElementById('L').textContent = Math.abs(angMomentum()).toExponential(3);
  document.getElementById('dtView').textContent = (integrator==='rkf45'? dtAdaptive : baseDt).toExponential(2);
}

// ========================= Integrators =========================
function stepVerlet(h){
  const a0 = bodies.map((_,i)=>accelOn(i,bodies));
  for(let i=0;i<bodies.length;i++){ const b=bodies[i]; b.v.x += 0.5*h*a0[i].x; b.v.y += 0.5*h*a0[i].y; }
  for(let i=0;i<bodies.length;i++){ const b=bodies[i]; b.r.x += h*b.v.x; b.r.y += h*b.v.y; }
  const a1 = bodies.map((_,i)=>accelOn(i,bodies));
  for(let i=0;i<bodies.length;i++){ const b=bodies[i]; b.v.x += 0.5*h*a1[i].x; b.v.y += 0.5*h*a1[i].y; }
}

// Yoshida 4th-order symplectic (composition of leapfrog)
const y_w1 = 1/(2 - Math.cbrt(2));
const y_w2 = - Math.cbrt(2)/(2 - Math.cbrt(2));
const y_b = [y_w1, y_w2, y_w1];
const y_a = [y_w1/2, (y_w1+y_w2)/2, (y_w1+y_w2)/2, y_w1/2];
function stepYoshida4(h){
  // sequence: for k=1..3: Kick(b_k*h) and Drift(a_k*h); final Drift(a_4*h)
  let a = null;
  for(let k=0;k<3;k++){
    a = bodies.map((_,i)=>accelOn(i,bodies));
    const hk = h*y_b[k];
    for(let i=0;i<bodies.length;i++){ const b=bodies[i]; b.v.x += hk*a[i].x; b.v.y += hk*a[i].y; }
    const dk = h*y_a[k];
    for(let i=0;i<bodies.length;i++){ const b=bodies[i]; b.r.x += dk*b.v.x; b.r.y += dk*b.v.y; }
  }
  // final drift
  const d4 = h*y_a[3];
  for(let i=0;i<bodies.length;i++){ const b=bodies[i]; b.r.x += d4*b.v.x; b.r.y += d4*b.v.y; }
}

function stepRK4(h){
  const n=bodies.length; const y0=deepCopy();
  function deriv(state){ const a = state.map((_,i)=>accelOn(i,state)); return state.map((b,i)=>({dr:{x:b.v.x,y:b.v.y}, dv:a[i]})); }
  const k1 = deriv(y0);
  const y1 = y0.map((b,i)=>({m:b.m, r:add(b.r,mul(k1[i].dr,h/2)), v:add(b.v,mul(k1[i].dv,h/2))}));
  const k2 = deriv(y1);
  const y2 = y0.map((b,i)=>({m:b.m, r:add(b.r,mul(k2[i].dr,h/2)), v:add(b.v,mul(k2[i].dv,h/2))}));
  const k3 = deriv(y2);
  const y3 = y0.map((b,i)=>({m:b.m, r:add(b.r,mul(k3[i].dr,h)), v:add(b.v,mul(k3[i].dv,h))}));
  const k4 = deriv(y3);
  for(let i=0;i<n;i++){
    bodies[i].r.x += (h/6)*(k1[i].dr.x + 2*k2[i].dr.x + 2*k3[i].dr.x + k4[i].dr.x);
    bodies[i].r.y += (h/6)*(k1[i].dr.y + 2*k2[i].dr.y + 2*k3[i].dr.y + k4[i].dr.y);
    bodies[i].v.x += (h/6)*(k1[i].dv.x + 2*k2[i].dv.x + 2*k3[i].dv.x + k4[i].dv.x);
    bodies[i].v.y += (h/6)*(k1[i].dv.y + 2*k2[i].dv.y + 2*k3[i].dv.y + k4[i].dv.y);
  }
}

// Adaptive RKF45 (Cash–Karp)
const CK = {
  a:[0,1/5,3/10,3/5,1,7/8],
  b:[
    [],
    [1/5],
    [3/40,9/40],
    [3/10,-9/10,6/5],
    [-11/54,5/2,-70/27,35/27],
    [1631/55296,175/512,575/13824,44275/110592,253/4096]
  ],
  c5:[37/378, 0, 250/621, 125/594, 0, 512/1771],      // 5th order
  c4:[2825/27648,0,18575/48384,13525/55296,277/14336,1/4] // 4th order
};

function rkf45_try(h){
  // returns {y: newState, err: maxNormError}
  const n=bodies.length; const y0=deepCopy();
  const k=[0,1,2,3,4,5].map(()=> new Array(n));
  function deriv(state){ const a = state.map((_,i)=>accelOn(i,state)); return state.map((b,i)=>({dr:{x:b.v.x,y:b.v.y}, dv:a[i]})); }
  const f = [];
  f[0]=deriv(y0); // k1
  const y1 = y0.map((b,i)=>({m:b.m, r:add(b.r,mul(f[0][i].dr, CK.a[1]*h)), v:add(b.v,mul(f[0][i].dv, CK.a[1]*h))}));
  f[1]=deriv(y1);
  const y2 = y0.map((b,i)=>({m:b.m, r:add(b.r, mul(add(mul(f[0][i].dr,CK.b[2][0]), mul(f[1][i].dr,CK.b[2][1])), h)), v:add(b.v, mul(add(mul(f[0][i].dv,CK.b[2][0]), mul(f[1][i].dv,CK.b[2][1])), h))}));
  f[2]=deriv(y2);
  const y3 = y0.map((b,i)=>({m:b.m, r:add(b.r, mul(add(add(mul(f[0][i].dr,CK.b[3][0]), mul(f[1][i].dr,CK.b[3][1])), mul(f[2][i].dr,CK.b[3][2])), h)), v:add(b.v, mul(add(add(mul(f[0][i].dv,CK.b[3][0]), mul(f[1][i].dv,CK.b[3][1]),), mul(f[2][i].dv,CK.b[3][2])), h))}));
  f[3]=deriv(y3);
  const y4 = y0.map((b,i)=>({m:b.m, r:add(b.r, mul(add(add(add(mul(f[0][i].dr,CK.b[4][0]), mul(f[1][i].dr,CK.b[4][1])), mul(f[2][i].dr,CK.b[4][2])), mul(f[3][i].dr,CK.b[4][3])), h)), v:add(b.v, mul(add(add(add(mul(f[0][i].dv,CK.b[4][0]), mul(f[1][i].dv,CK.b[4][1])), mul(f[2][i].dv,CK.b[4][2])), mul(f[3][i].dv,CK.b[4][3])), h))}));
  f[4]=deriv(y4);
  const y5 = y0.map((b,i)=>({m:b.m, r:add(b.r, mul(add(add(add(add(mul(f[0][i].dr,CK.b[5][0]), mul(f[1][i].dr,CK.b[5][1])), mul(f[2][i].dr,CK.b[5][2])), mul(f[3][i].dr,CK.b[5][3])), mul(f[4][i].dr,CK.b[5][4])), h)), v:add(b.v, mul(add(add(add(add(mul(f[0][i].dv,CK.b[5][0]), mul(f[1][i].dv,CK.b[5][1])), mul(f[2][i].dv,CK.b[5][2])), mul(f[3][i].dv,CK.b[5][3])), mul(f[4][i].dv,CK.b[5][4])), h))}));
  f[5]=deriv(y5);
  // combine for y5 (5th) and y4 (4th)
  const y5th = y0.map((b,i)=>({m:b.m, r:{x:b.r.x + h*(CK.c5[0]*f[0][i].dr.x + CK.c5[2]*f[2][i].dr.x + CK.c5[3]*f[3][i].dr.x + CK.c5[5]*f[5][i].dr.x), y:b.r.y + h*(CK.c5[0]*f[0][i].dr.y + CK.c5[2]*f[2][i].dr.y + CK.c5[3]*f[3][i].dr.y + CK.c5[5]*f[5][i].dr.y)}, v:{x:b.v.x + h*(CK.c5[0]*f[0][i].dv.x + CK.c5[2]*f[2][i].dv.x + CK.c5[3]*f[3][i].dv.x + CK.c5[5]*f[5][i].dv.x), y:b.v.y + h*(CK.c5[0]*f[0][i].dv.y + CK.c5[2]*f[2][i].dv.y + CK.c5[3]*f[3][i].dv.y + CK.c5[5]*f[5][i].dv.y)}}));
  const y4th = y0.map((b,i)=>({m:b.m, r:{x:b.r.x + h*(CK.c4[0]*f[0][i].dr.x + CK.c4[2]*f[2][i].dr.x + CK.c4[3]*f[3][i].dr.x + CK.c4[4]*f[4][i].dr.x + CK.c4[5]*f[5][i].dr.x), y:b.r.y + h*(CK.c4[0]*f[0][i].dr.y + CK.c4[2]*f[2][i].dr.y + CK.c4[3]*f[3][i].dr.y + CK.c4[4]*f[4][i].dr.y + CK.c4[5]*f[5][i].dr.y)}, v:{x:b.v.x + h*(CK.c4[0]*f[0][i].dv.x + CK.c4[2]*f[2][i].dv.x + CK.c4[3]*f[3][i].dv.x + CK.c4[4]*f[4][i].dv.x + CK.c4[5]*f[5][i].dv.x), y:b.v.y + h*(CK.c4[0]*f[0][i].dv.y + CK.c4[2]*f[2][i].dv.y + CK.c4[3]*f[3][i].dv.y + CK.c4[4]*f[4][i].dv.y + CK.c4[5]*f[5][i].dv.y)}}));
  // error estimate: max norm of state increments
  let err = 0;
  for(let i=0;i<n;i++){
    const ri = Math.hypot(y5th[i].r.x - y4th[i].r.x, y5th[i].r.y - y4th[i].r.y);
    const vi = Math.hypot(y5th[i].v.x - y4th[i].v.x, y5th[i].v.y - y4th[i].v.y);
    const scaleR = tolAbs + tolRel * max2(Math.hypot(y0[i].r.x,y0[i].r.y), Math.hypot(y5th[i].r.x,y5th[i].r.y));
    const scaleV = tolAbs + tolRel * max2(Math.hypot(y0[i].v.x,y0[i].v.y), Math.hypot(y5th[i].v.x,y5th[i].v.y));
    err = Math.max(err, ri/scaleR, vi/scaleV);
  }
  return {y:y5th, err};
}
function max2(a,b){ return a>b?a:b; }

function rkf45_step(){
  let h = dtAdaptive; let accepted=false; let attempt=0; let yNew=null; let err=0;
  while(!accepted && attempt<12){
    const trial = rkf45_try(h); err = trial.err; yNew = trial.y; attempt++;
    if (err <= 1.0 || h<=dtMin*0.999){ accepted=true; }
    else { // reject and shrink
      const factor = Math.max(0.2, Math.min(0.9, safety * Math.pow(1/err, 0.2)));
      h = Math.max(dtMin, h*factor);
    }
  }
  if(!accepted){ if(rkfRejectPause) running=false; rkfRejectStreak++; }
  else { rkfRejectStreak=0; bodies = yNew; }
  // select next step size
  let factor = (err>1e-16) ? safety * Math.pow(1/err, 0.2) : scaleMax; // (p=4 => 1/(p+1)=0.2)
  factor = Math.max(0.5, Math.min(scaleMax, factor));
  dtAdaptive = h * factor;
  if(rkfClamp){ dtAdaptive = Math.min(dtMax, Math.max(dtMin, dtAdaptive)); }
}

function integrate(h){
  if(integrator==='rk4') return stepRK4(h);
  if(integrator==='yoshida4') return stepYoshida4(h);
  if(integrator==='rkf45') return rkf45_step();
  return stepVerlet(h);
}

// ========================= Collisions & Trails =========================
function handleCollisions(){
  for(let i=0;i<bodies.length;i++) for(let j=i+1;j<bodies.length;j++){
    const bi=bodies[i], bj=bodies[j]; const dx=bj.r.x-bi.r.x, dy=bj.r.y-bi.r.y; const d=Math.hypot(dx,dy);
    if(d < collideR){
      if(mergeOn){ // momentum-conserving merge at COM
        const M = bi.m + bj.m;
        const r = {x:(bi.r.x*bi.m + bj.r.x*bj.m)/M, y:(bi.r.y*bi.m + bj.r.y*bj.m)/M};
        const v = {x:(bi.v.x*bi.m + bj.v.x*bj.m)/M, y:(bi.v.y*bi.m + bj.v.y*bj.m)/M};
        bodies.splice(j,1); bodies.splice(i,1,{m:M,r,v,color:'var(--merge)',trail:[]});
        return; // restart search after mutation
      }
      if(elasticOn){
        const n={x:dx/d,y:dy/d}; const mi=bi.m,mj=bj.m;
        const viN = bi.v.x*n.x + bi.v.y*n.y; const vjN = bj.v.x*n.x + bj.v.y*n.y;
        const viN2 = (viN*(mi-mj) + 2*mj*vjN) / (mi+mj);
        const vjN2 = (vjN*(mj-mi) + 2*mi*viN) / (mi+mj);
        const dvi = (viN2-viN), dvj=(vjN2-vjN);
        bi.v.x += dvi*n.x; bi.v.y += dvi*n.y; bj.v.x += dvj*n.x; bj.v.y += dvj*n.y;
        const overlap = collideR - d + 1e-4; bi.r.x -= n.x*overlap* mj/(mi+mj); bi.r.y -= n.y*overlap* mj/(mi+mj); bj.r.x += n.x*overlap* mi/(mi+mj); bj.r.y += n.y*overlap* mi/(mi+mj);
      }
    }
  }
}

function pushTrails(){ bodies.forEach(b=>{ b.trail.push({x:b.r.x,y:b.r.y}); if(b.trail.length>trailLen) b.trail.shift(); }); }
function clearTrails(){ bodies.forEach(b=> b.trail=[]); }

// ========================= Rendering =========================
function drawGrid(){ if(!showGrid) return; ctx.save(); ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.06)';
  const start=s2w({x:0,y:H}), end=s2w({x:W,y:0}); const step=0.5;
  for(let x=Math.ceil(start.x/step)*step; x<end.x; x+=step){ const p1=w2s({x, y:start.y}), p2=w2s({x, y:end.y}); ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke(); }
  for(let y=Math.ceil(start.y/step)*step; y<end.y; y+=step){ const p1=w2s({x:start.x, y}), p2=w2s({x:end.x, y}); ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke(); }
  // axes
  ctx.strokeStyle='rgba(255,255,255,0.15)'; const x1=w2s({x:start.x,y:0}),x2=w2s({x:end.x,y:0}),y1=w2s({x:0,y:start.y}),y2=w2s({x:0,y:end.y});
  ctx.beginPath(); ctx.moveTo(x1.x,x1.y); ctx.lineTo(x2.x,x2.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(y1.x,y1.y); ctx.lineTo(y2.x,y2.y); ctx.stroke(); ctx.restore(); }

function drawTrails(){ ctx.save(); ctx.lineWidth=1.2; bodies.forEach(b=>{ ctx.strokeStyle=b.color+'cc'; ctx.beginPath(); for(let i=0;i<b.trail.length;i++){ const p=w2s(b.trail[i]); if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.stroke(); }); ctx.restore(); }

function drawBodies(){ ctx.save(); bodies.forEach(b=>{ const p=w2s(b.r); const r=Math.max(2, 6 + Math.log10(1+b.m)*3); const g=ctx.createRadialGradient(p.x,p.y,1,p.x,p.y,r); g.addColorStop(0,'#fff'); g.addColorStop(0.4,b.color); g.addColorStop(1,'transparent'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); if(showVec){ const v=mul(b.v,0.12*zoom); ctx.strokeStyle=b.color; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(p.x+v.x,p.y-v.y); ctx.stroke(); }}); ctx.restore(); }

function render(){ ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,W,H); drawGrid(); drawTrails(); drawBodies(); drawMini(); }

function drawMini(){ // draw COM frame thumbnail
  miniCtx.setTransform(1,0,0,1,0,0); miniCtx.clearRect(0,0,miniCanvas.width,miniCanvas.height);
  const w=miniCanvas.width, h=miniCanvas.height; miniCtx.fillStyle='#0b1426'; miniCtx.fillRect(0,0,w,h);
  miniCtx.strokeStyle='#ffffff22'; miniCtx.lineWidth=1; miniCtx.beginPath(); miniCtx.moveTo(0,h/2); miniCtx.lineTo(w,h/2); miniCtx.moveTo(w/2,0); miniCtx.lineTo(w/2,h); miniCtx.stroke();
  const z = Math.min(w,h)*0.35; // fixed zoom for mini
  const com = {x:0,y:0}; const M=bodies.reduce((s,b)=>s+b.m,0); bodies.forEach(b=>{ com.x+=b.r.x*b.m; com.y+=b.r.y*b.m; }); com.x/=M; com.y/=M;
  bodies.forEach(b=>{ const x = w/2 + (b.r.x-com.x)*z; const y = h/2 - (b.r.y-com.y)*z; miniCtx.fillStyle=b.color; miniCtx.beginPath(); miniCtx.arc(x,y,4*DPR,0,Math.PI*2); miniCtx.fill(); });
}

// ========================= Interaction =========================
let dragging=false,last={x:0,y:0};
canvas.addEventListener('mousedown',e=>{dragging=true; last={x:e.clientX,y:e.clientY};});
window.addEventListener('mousemove',e=>{ if(!dragging) return; const dx=e.clientX-last.x, dy=e.clientY-last.y; offset.x-=dx/zoom; offset.y+=dy/zoom; last={x:e.clientX,y:e.clientY}; });
window.addEventListener('mouseup',()=>dragging=false);
canvas.addEventListener('wheel',e=>{ const rect=canvas.getBoundingClientRect(); const m={x:e.clientX-rect.left,y:e.clientY-rect.top}; const wb=s2w(m); const s=Math.exp(-e.deltaY*0.001); zoom=Math.min(1200,Math.max(40,zoom*s)); const wa=s2w(m); offset.x += wb.x-wa.x; offset.y += wb.y-wa.y; },{passive:true});
canvas.addEventListener('dblclick',()=>{offset={x:0,y:0}; zoom=250;});

// ========================= Controls =========================
const $=id=>document.getElementById(id);
function read(){
  G=parseFloat($('G').value); eps=parseFloat($('eps').value); baseDt=parseFloat($('dt').value); speed=parseInt($('speed').value); trailLen=parseInt($('trailLen').value); showGrid=$('showGrid').checked; showVec=$('showVec').checked; integrator=$('integrator').value; mergeOn=$('merge').checked; collideR=parseFloat($('collideR').value); elasticOn=$('elastic').checked; tolAbs=parseFloat($('tolAbs').value); tolRel=parseFloat($('tolRel').value); dtMin=parseFloat($('dtMin').value); dtMax=parseFloat($('dtMax').value); safety=parseFloat($('safety').value); scaleMax=parseFloat($('scaleMax').value); rkfClamp=$('rkfClamp').checked; rkfRejectPause=$('rkfRejectPause').checked; }

function pushInputs(){ const b=bodies; $('m1').value=b[0]?.m??1; $('m2').value=b[1]?.m??1; $('m3').value=b[2]?.m??1; $('x1').value=b[0]?.r.x??0; $('x2').value=b[1]?.r.x??0; $('x3').value=b[2]?.r.x??0; $('y1').value=b[0]?.r.y??0; $('y2').value=b[1]?.r.y??0; $('y3').value=b[2]?.r.y??0; $('vx1').value=b[0]?.v.x??0; $('vx2').value=b[1]?.v.x??0; $('vx3').value=b[2]?.v.x??0; $('vy1').value=b[0]?.v.y??0; $('vy2').value=b[1]?.v.y??0; $('vy3').value=b[2]?.v.y??0; }

$('apply').addEventListener('click',()=>{ bodies=[ {m:parseFloat($('m1').value), r:{x:parseFloat($('x1').value),y:parseFloat($('y1').value)}, v:{x:parseFloat($('vx1').value),y:parseFloat($('vy1').value)}, color:'#ff5f6d', trail:[]}, {m:parseFloat($('m2').value), r:{x:parseFloat($('x2').value),y:parseFloat($('y2').value)}, v:{x:parseFloat($('vx2').value),y:parseFloat($('vy2').value)}, color:'#39d98a', trail:[]}, {m:parseFloat($('m3').value), r:{x:parseFloat($('x3').value),y:parseFloat($('y3').value)}, v:{x:parseFloat($('vx3').value),y:parseFloat($('vy3').value)}, color:'#62d0ff', trail:[]} ]; updateHUD(); });
$('com').addEventListener('click',()=>{ zeroCOM(); pushInputs(); });
$('play').addEventListener('click',()=>{ running=!running; $('play').textContent = running? '⏸ Pause' : '▶ Play'; });
$('step').addEventListener('click',()=>{ integrate(baseDt); handleCollisions(); pushTrails(); updateHUD(); render(); });
$('reset').addEventListener('click',()=>{ defaultBodies(); zeroCOM(); pushInputs(); clearTrails(); updateHUD(); render(); });
$('clear').addEventListener('click',clearTrails);
$('fig8').addEventListener('click',()=>{ presetFigure8(); });
$('lagrange').addEventListener('click',()=>{ presetLagrange(); });
['G','eps','dt','speed','trailLen','showGrid','showVec','integrator','merge','collideR','elastic','tolAbs','tolRel','dtMin','dtMax','safety','scaleMax','rkfClamp','rkfRejectPause'].forEach(id=>{ $(id).addEventListener('input',read); $(id).addEventListener('change',read); });

$('export').addEventListener('click',()=>{ const dump={G,eps,integrator,baseDt,dtAdaptive, tolAbs,tolRel,dtMin,dtMax,safety,scaleMax,bodies}; $('io').value=JSON.stringify(dump,null,2); });
$('import').addEventListener('click',()=>{ try{ const obj=JSON.parse($('io').value); if(obj.G!==undefined){ G=obj.G; eps=obj.eps; integrator=obj.integrator; baseDt=obj.baseDt; dtAdaptive=obj.dtAdaptive||baseDt; tolAbs=obj.tolAbs||tolAbs; tolRel=obj.tolRel||tolRel; dtMin=obj.dtMin||dtMin; dtMax=obj.dtMax||dtMax; safety=obj.safety||safety; scaleMax=obj.scaleMax||scaleMax; bodies=obj.bodies.map(b=>({m:b.m,r:{x:b.r.x,y:b.r.y},v:{x:b.v.x,y:b.v.y},color:b.color||'#fff',trail:[]})); pushInputs(); read(); } }catch(e){ alert('Invalid JSON'); } });

window.addEventListener('keydown',e=>{ if(['INPUT','SELECT','TEXTAREA'].includes(document.activeElement.tagName)) return; const k=e.key.toLowerCase(); if(e.code==='Space'){e.preventDefault(); $('play').click();} if(k==='s') $('step').click(); if(k==='r') $('reset').click(); if(k==='c') $('clear').click(); });

function presetFigure8(){ bodies=[ {m:1, r:{x:-0.97000436, y: 0.24308753}, v:{x: 0.4662036850, y: 0.4323657300}, color:'#ff5f6d', trail:[]}, {m:1, r:{x: 0.97000436, y:-0.24308753}, v:{x: 0.4662036850, y: 0.4323657300}, color:'#39d98a', trail:[]}, {m:1, r:{x: 0.0, y: 0.0}, v:{x:-0.93240737, y:-0.86473146}, color:'#62d0ff', trail:[]} ]; zeroCOM(); pushInputs(); }
function presetLagrange(){ const R=0.6; const v=Math.sqrt(G/(4*R)); bodies=[ {m:1, r:{x: R, y: 0}, v:{x: 0, y: v}, color:'#ff5f6d', trail:[]}, {m:1, r:{x:-R*Math.cos(Math.PI/3), y: R*Math.sin(Math.PI/3)}, v:{x: v*Math.sin(Math.PI/3), y: v*Math.cos(Math.PI/3)}, color:'#39d98a', trail:[]}, {m:1, r:{x:-R*Math.cos(Math.PI/3), y:-R*Math.sin(Math.PI/3)}, v:{x:-v*Math.sin(Math.PI/3), y: v*Math.cos(Math.PI/3)}, color:'#62d0ff', trail:[]} ]; zeroCOM(); pushInputs(); }

// ========================= Main Loop =========================
function frame(){
  if(running){ for(let s=0;s<speed;s++){ if(integrator==='rkf45'){ rkf45_step(); } else { integrate(baseDt); } handleCollisions(); pushTrails(); } updateHUD(); }
  render(); requestAnimationFrame(frame);
}
read(); pushInputs(); updateHUD(); pushTrails(); requestAnimationFrame(frame);
</script>
</body>
</html>
